<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Sujet de discussion - SportConnect</title>
		<link rel="stylesheet" href="style.css" />
		<script src="js/main.js" defer></script>
		<script>
			document.addEventListener('api-initialized', async () => {
				// Récupérer le nom d'utilisateur depuis le localStorage ou utiliser "Anonyme"
				const me = await window.api.getMeUser();
				if (!me) {
					// Rediriger vers la page de connexion si l'utilisateur n'est pas connecté
					window.location.href = '/login.html';
					return;
				}
				const username = me.username || 'Anonyme';
				const userId = me.id;

				// Utiliser le token JWT pour l'authentification du socket
				const socket = io('ws://localhost:3001', {
					auth: {
						token: window.api.token
					}
				});

				socket.on('connect', () => {
					console.log('Connecté au serveur Socket.IO');
				});

				const topicTitle = document.getElementById('topic-title');
				const messagesContainer = document.getElementById('messages-container');
				const typingIndicator = document.getElementById('typing-indicator');
				const newMessageForm = document.getElementById('new-message-form');
				const messageText = document.getElementById('message-text');

				const topicId = new URLSearchParams(window.location.search).get('id');

				if (topicId) {
					socket.emit('join_topic', topicId);
					try {
						// Utiliser l'API pour récupérer les détails du sujet, y compris les messages
						const response = await window.api.get('forum', { populate: 'deep' });
						const topic = response.data.attributes.topics.find(t => t.id == topicId);

						if (topic) {
							topicTitle.textContent = topic.title;
							renderMessages(topic.messages);
						} else {
							topicTitle.textContent = 'Sujet non trouvé';
						}
					} catch (error) {
						console.error('Erreur lors de la récupération du sujet:', error);
						topicTitle.textContent = 'Erreur de chargement';
					}
				} else {
					topicTitle.textContent = 'Aucun sujet sélectionné';
				}

				function renderMessages(messages) {
					messagesContainer.innerHTML = ''; // Vider les anciens messages
					if (messages && messages.length > 0) {
						const messagesList = document.createElement('ul');
						messagesList.className = 'messages-list';

						messages.forEach(message => {
							const messageItem = createMessageElement(message);
							messagesList.appendChild(messageItem);
						});
						messagesContainer.appendChild(messagesList);
					} else {
						messagesContainer.innerHTML = '<p>Aucun message dans ce sujet pour le moment.</p>';
					}
				}

				function createMessageElement(message) {
					const messageItem = document.createElement('li');
					messageItem.innerHTML = `
            <div class="message-author">${message.author}</div>
            <div class="message-text">${message.text}</div>
            <div class="message-date">${new Date(message.date).toLocaleString()}</div>
        `;
					return messageItem;
				}


				socket.on('new_message', (message) => {
					if (message.topicId == topicId) {
						let messagesList = messagesContainer.querySelector('.messages-list');
						if (!messagesList) {
							messagesContainer.innerHTML = '';
							messagesList = document.createElement('ul');
							messagesList.className = 'messages-list';
							messagesContainer.appendChild(messagesList);
						}
						const messageItem = createMessageElement(message);
						messagesList.appendChild(messageItem);
						window.scrollTo(0, document.body.scrollHeight); // Auto-scroll
					}
				});

				socket.on('error_creating_message', (data) => {
					alert(`Erreur lors de l'envoi du message: ${data.message}`);
				});

				socket.on('typing_users_update', (typingUsers) => {
					// Filtrer l'utilisateur actuel
					const otherTypingUsers = typingUsers.filter(u => u !== username);

					if (otherTypingUsers.length === 0) {
						typingIndicator.style.display = 'none';
					} else {
						let text = '';
						if (otherTypingUsers.length === 1) {
							text = `${otherTypingUsers[0]} est en train d'écrire...`;
						} else if (otherTypingUsers.length === 2) {
							text = `${otherTypingUsers[0]} et ${otherTypingUsers[1]} sont en train d'écrire...`;
						} else {
							const othersCount = otherTypingUsers.length - 2;
							text = `${otherTypingUsers[0]}, ${otherTypingUsers[1]} et ${othersCount} autre(s) personne(s) sont en train d'écrire...`;
						}
						typingIndicator.textContent = text;
						typingIndicator.style.display = 'block';
					}
				});


				let typingTimer;
				const typingTimeout = 2000; // 2 secondes

				if (messageText) {
					messageText.addEventListener('input', () => {
						clearTimeout(typingTimer);
						socket.emit('typing', { topicId });
						typingTimer = setTimeout(() => {
							socket.emit('stop_typing', { topicId });
						}, typingTimeout);
					});
				}

				if (newMessageForm) {
					newMessageForm.addEventListener('submit', (e) => {
						e.preventDefault();
						const text = messageText.value.trim();
						if (text) {
							const newMessage = {
								author: username,
								text: text,
								date: new Date().toISOString()
							};
							socket.emit('new_message', { topicId, message: newMessage });
							messageText.value = '';
							// Arrêter d'envoyer "typing" après l'envoi du message
							clearTimeout(typingTimer);
							socket.emit('stop_typing', { topicId });
						}
					});
				}
			});
		</script>
	    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
	<body>
		<main class="container">
			<h1 id="topic-title"></h1>
			<div id="messages-container"></div>
			<div id="typing-indicator" class="typing-indicator" style="display: none;">
				Quelqu'un est en train d'écrire...
			</div>
			<form id="new-message-form">
				<h2>Ajouter un message</h2>
				<textarea id="message-text" placeholder="Votre message" required></textarea>
				<button type="submit">Envoyer</button>
			</form>
		</main>
	</body>
</html>
